# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, TextIO

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.builder import Builder
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project, Path("build"))
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        f.write(f"builddir = {self._escape_path(project.build_dir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")

        # Collect all unique rules from targets
        for target in project.targets:
            for node in target.nodes:
                if isinstance(node, FileNode) and node.builder is not None:
                    # Find environment for this target
                    env = self._find_env_for_node(node, project)
                    self._ensure_rule(f, node, target, env)

        # Also check nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, None, env)

        f.write("\n")

    def _find_env_for_node(self, node: FileNode, project: Project) -> Environment | None:
        """Find the environment that created a node."""
        for env in project.environments:
            if node in getattr(env, "_created_nodes", []):
                return env
        return None

    def _ensure_rule(
        self, f: TextIO, node: FileNode, target: Target | None, env: Environment | None = None
    ) -> str:
        """Ensure a rule exists for this node's builder, return rule name."""
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get command template from build info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Create a unique key for this rule based on tool and command var
        rule_key = f"{tool_name}_{command_var}"

        if rule_key not in self._rules:
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Get the actual command from the environment
            command = f"echo 'No command for {rule_key}'"
            if env is not None:
                tool_config = getattr(env, tool_name, None)
                if tool_config is not None:
                    cmd_template = getattr(tool_config, command_var, None)
                    if cmd_template:
                        # Expand tool variables using subst() with ninja shell
                        # Template can be a string or list of tokens
                        # Using shell="ninja" ensures $in, $out aren't quoted
                        # Ninja variables like $in, $out are escaped as $$in, $$out
                        # in the toolchain defaults, and become $in, $out after subst
                        command = env.subst(cmd_template, shell="ninja")

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = {command}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support if this looks like a compiler
            if tool_name in ("cc", "cxx", "cycc"):
                f.write("  depfile = $out.d\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        written_nodes: set[Path] = set()

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project, written_nodes: set[Path]
    ) -> None:
        """Write build statements for a single target."""
        for node in target.nodes:
            if isinstance(node, FileNode) and node.builder is not None:
                if node.path not in written_nodes:
                    self._write_build_statement(f, node, target, project)
                    written_nodes.add(node.path)

    def _write_build_statement(
        self, f: TextIO, node: FileNode, target: Target | None, project: Project | None = None
    ) -> None:
        """Write a single build statement.

        Handles both single-output and multi-output builds. Multi-output builds
        use Ninja's implicit output syntax: build out1 out2 | implicit_out: rule deps
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources: list[Node] = build_info.get("sources", [])

        rule_name = f"{tool_name}_{command_var}"

        # Handle multi-output builds
        outputs_info = build_info.get("outputs")
        if outputs_info:
            # Multi-output build
            explicit_outputs: list[str] = []
            implicit_outputs: list[str] = []

            for name, info in outputs_info.items():
                path = self._escape_path(info["path"])
                if info.get("implicit", False):
                    implicit_outputs.append(path)
                else:
                    explicit_outputs.append(path)

            output = " ".join(explicit_outputs)
            if implicit_outputs:
                output += " | " + " ".join(implicit_outputs)
        else:
            # Single-output build
            output = self._escape_path(node.path)

        # Explicit dependencies (sources) - use paths relative to build dir
        # For source files, we need to reference them from the build directory
        def get_source_path(s: FileNode) -> str:
            # If source is in build dir, use relative path
            # Otherwise, make it relative to build dir or absolute
            if project and not s.path.is_absolute():
                # Make path relative from build dir to source dir
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return self._escape_path(src_path)
            return self._escape_path(s.path)

        explicit_deps = " ".join(
            get_source_path(s) for s in sources if isinstance(s, FileNode)
        )

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Order-only dependencies (directories that must exist)
        order_only = ""
        output_dir = node.path.parent
        if output_dir != Path(".") and output_dir != Path(""):
            order_only = f" || {self._escape_path(output_dir)}"

        f.write(f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n")

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info, project)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        build_info: dict[str, object],
        project: Project | None = None,
    ) -> None:
        """Write variables for a build statement.

        For multi-output builds, also writes out_<name> variables for each output.
        """
        sources: list[Node] = build_info.get("sources", [])  # type: ignore[assignment]

        # Standard variables - use absolute paths for sources
        def get_source_path(s: FileNode) -> str:
            if project and not s.path.is_absolute():
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return str(src_path)
            return str(s.path)

        source_paths = " ".join(
            get_source_path(s) for s in sources if isinstance(s, FileNode)
        )
        if source_paths:
            f.write(f"  in = {source_paths}\n")
        f.write(f"  out = {node.path}\n")

        # For multi-output builds, write out_<name> for each output
        outputs_info = build_info.get("outputs")
        if outputs_info:
            for name, info in outputs_info.items():  # type: ignore[union-attr]
                # Write out_<name> variable for each output
                f.write(f"  out_{name} = {info['path']}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets."""
        f.write("# Default targets\n")
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            for node in target.nodes:
                if isinstance(node, FileNode):
                    defaults.append(self._escape_path(node.path))

        # If no default targets, use all program/library outputs from environments
        if not defaults:
            for env in project.environments:
                for node in getattr(env, "_created_nodes", []):
                    if isinstance(node, FileNode) and node.builder is not None:
                        # Check if this is a "final" output (Program, SharedLibrary)
                        build_info = getattr(node, "_build_info", {})
                        tool = build_info.get("tool", "")
                        if tool == "link":
                            defaults.append(self._escape_path(node.path))

        if defaults:
            f.write(f"default {' '.join(defaults)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        """
        path_str = str(path)
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _get_rule_command(
        self, env: Environment, builder: Builder, build_info: dict[str, object]
    ) -> str:
        """Get the command for a rule from the environment.

        Expands the command template with environment variables.
        """
        tool_name = str(build_info.get("tool", "unknown"))
        command_var = str(build_info.get("command_var", "cmdline"))

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"echo 'No command template: {tool_name}.{command_var}'"

        # Expand variables using subst() with ninja shell
        # Template can be a string or list of tokens
        # Using shell="ninja" ensures $in, $out aren't quoted
        # Note: $in and $out are left unexpanded for Ninja (they're $$in, $$out in templates)
        return env.subst(command_template, shell="ninja")
