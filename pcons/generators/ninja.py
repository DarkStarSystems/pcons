# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import os
import re
from pathlib import Path
from typing import TYPE_CHECKING, Any, TextIO, cast

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator
from pcons.tools.toolchain import ToolchainContext

if TYPE_CHECKING:
    from pcons.core.builder import Builder
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project, Path("build"))
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0
        self._output_dir: Path | None = None  # Set during generate()
        self._project_root: Path | None = None  # Set during generate()
        self._topdir: str = ".."  # Relative path from output_dir to project root

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0
        self._output_dir = output_dir.resolve()
        self._project_root = project.root_dir.resolve()
        # Compute relative path from output_dir to project root
        try:
            self._topdir = str(
                Path(os.path.relpath(self._project_root, self._output_dir))
            )
        except ValueError:
            # On Windows, relpath fails for paths on different drives
            self._topdir = str(self._project_root)

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        # builddir is "." since the ninja file is in the build directory
        f.write("builddir = .\n")
        # topdir is the relative path from build dir to project root
        # Used for source files, include paths, etc.
        f.write(f"topdir = {self._escape_path(self._topdir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")
        # Note: Ninja automatically creates output directories before running
        # commands, so we don't need explicit mkdir rules.

        # Collect all unique rules from targets
        for target in project.targets:
            env = target._env
            for node in self._get_target_build_nodes(target):
                self._ensure_rule(f, node, target, env)

        # Also check nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, None, env)

        f.write("\n")

    def _find_env_for_node(
        self, node: FileNode, project: Project
    ) -> Environment | None:
        """Find the environment that created a node."""
        for env in project.environments:
            if node in getattr(env, "_created_nodes", []):
                return env
        return None

    def _ensure_rule(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        env: Environment | None = None,
    ) -> str:
        """Ensure a rule exists for this node's builder, return rule name.

        For target-centric builds, the rule command may include placeholders
        for effective requirements ($includes, $defines, $extra_flags, etc.)
        that are filled in via per-build variables.
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get command template from build info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = build_info.get("context") is not None

        # Check if this is a generic command (has custom rule_name and command)
        custom_rule_name = build_info.get("rule_name")
        custom_command = build_info.get("command")

        # Create a unique key for this rule based on tool, command var, and env
        # Each env gets its own rule so env-specific settings (frameworks, libs, etc.)
        # are correctly baked into the rule via template expansion.
        if custom_rule_name:
            # Generic command builder uses custom rule name
            rule_key = custom_rule_name
        else:
            rule_key = f"{tool_name}_{command_var}"
            if has_effective_reqs:
                # Include env identity so each env gets its own rule
                # This allows env.Framework(), env.link.libs, etc. to be baked in
                # Use env name if available for readability, plus id for uniqueness
                env_suffix = self._get_env_suffix(env)
                rule_key += f"_{env_suffix}"

        if rule_key not in self._rules:
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Get the actual command from the environment or build_info
            command = f"echo 'No command for {rule_key}'"

            # Special case for copy command (from Install) - check this BEFORE
            # generic command since Install also sets a "command" field
            if tool_name == "copy":
                copy_cmd = build_info.get("copy_cmd", "cp $in $out")
                command = copy_cmd + "$post_build"
                description = "INSTALL $out"
            # Special case for lipo (universal binary creation on macOS)
            elif tool_name == "lipo":
                command = "lipo -create -output $out $in"
                description = "LIPO $out"
            # Archive builders (Tarfile, Zipfile)
            # Use sys.executable (Python that ran pcons) with the standalone helper script
            elif tool_name == "tarfile":
                import sys

                import pcons.util.archive_helper as archive_mod

                compression = build_info.get("compression")
                base_dir = build_info.get("base_dir", ".")
                compression_flag = f"--compression {compression}" if compression else ""
                helper_path = Path(archive_mod.__file__)  # type: ignore[arg-type]
                command = (
                    f"{sys.executable} {helper_path} --type tar "
                    f"{compression_flag} --output $out --base-dir {base_dir} $in"
                )
                description = "TAR $out"
            elif tool_name == "zipfile":
                import sys

                import pcons.util.archive_helper as archive_mod

                base_dir = build_info.get("base_dir", ".")
                helper_path = Path(archive_mod.__file__)  # type: ignore[arg-type]
                command = (
                    f"{sys.executable} {helper_path} --type zip "
                    f"--output $out --base-dir {base_dir} $in"
                )
                description = "ZIP $out"
            # Check for generic command builder (has custom command in build_info)
            elif custom_command:
                # Generic command builder - use the command directly
                # Convert $SOURCE, $TARGET etc. to Ninja $in, $out
                command = self._convert_command_variables(custom_command)
                description = "COMMAND $out"
            elif env is not None:
                tool_config = getattr(env, tool_name, None)
                if tool_config is not None:
                    cmd_template = getattr(tool_config, command_var, None)
                    if cmd_template:
                        # Expand tool variables using subst() with ninja shell
                        # Template can be a string or list of tokens
                        # Using shell="ninja" ensures $in, $out aren't quoted
                        # Ninja variables like $in, $out are escaped as $$in, $$out
                        # in the toolchain defaults, and become $in, $out after subst
                        #
                        # Since each env gets its own rule, env-specific settings
                        # (frameworks, libs, etc.) are correctly baked into this
                        # env's rule via normal template expansion.
                        command = env.subst(cmd_template, shell="ninja")

                        # For target-centric builds, append effective requirement
                        # placeholders that will be filled per-build
                        if has_effective_reqs:
                            command = self._augment_command_with_effective_vars(
                                command, command_var
                            )
                        else:
                            # For non-effective builds, still add $post_build
                            command = command.rstrip() + "$post_build"

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = {command}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support based on builder configuration
            depfile = build_info.get("depfile")
            deps_style = build_info.get("deps_style")

            if deps_style == "msvc":
                f.write("  deps = msvc\n")
            elif deps_style == "gcc":
                if depfile:
                    f.write(f"  depfile = {depfile}\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _augment_command_with_effective_vars(
        self, command: str, command_var: str
    ) -> str:
        """Augment a command with effective requirement variables.

        Adds placeholders like $includes, $defines, $extra_flags that will
        be filled in per-build based on the target's effective requirements.

        Args:
            command: The base command template.
            command_var: The command variable name (objcmd, linkcmd, etc.)

        Returns:
            Command with effective requirement placeholders added.
        """
        # For compilation commands (objcmd), add includes, defines, extra_flags
        if command_var == "objcmd":
            # Insert before the output flag (usually -o or -c)
            # We'll append them before the source file
            # Format: cmd $flags $includes $defines $extra_flags -c $in -o $out
            if "$in" in command:
                command = command.replace("$in", "$includes $defines $extra_flags $in")
        # For link commands (linkcmd, sharedcmd, progcmd), add ldflags, libdirs, libs
        elif command_var in ("linkcmd", "sharedcmd", "progcmd"):
            # Append link flags at the end
            if "$out" in command:
                # Add after the sources/objects
                command = command.rstrip()
                if not command.endswith("$libs"):
                    command += " $ldflags $libdirs $libs"
        # For archive commands (archivecmd), no changes needed

        # For all commands, append $post_build placeholder for post-build commands
        # This will be empty unless a target has post_build commands
        command = command.rstrip() + "$post_build"

        return command

    def _convert_command_variables(self, command: str) -> str:
        """Convert env.Command() variables to Ninja variables.

        Converts SCons-style variables to Ninja-style:
        - $SOURCE, $SOURCES -> $in
        - $TARGET, $TARGETS -> $out
        - ${SOURCES[n]} -> indexed source (handled at build time)
        - ${TARGETS[n]} -> indexed target (handled at build time)

        Args:
            command: The command template with SCons-style variables.

        Returns:
            Command with Ninja-style variables.
        """
        import re

        # Convert plural forms first (so they don't match singular)
        command = command.replace("$SOURCES", "$in")
        command = command.replace("$TARGETS", "$out")

        # Convert singular forms
        command = command.replace("$SOURCE", "$in")
        command = command.replace("$TARGET", "$out")

        # Handle indexed access ${SOURCES[n]} and ${TARGETS[n]}
        # These need special handling - we'll convert to per-build variables
        # that will be filled in by _write_build_variables
        def replace_indexed_source(match: re.Match[str]) -> str:
            index = match.group(1)
            return f"$source_{index}"

        def replace_indexed_target(match: re.Match[str]) -> str:
            index = match.group(1)
            return f"$target_{index}"

        command = re.sub(r"\$\{SOURCES\[(\d+)\]\}", replace_indexed_source, command)
        command = re.sub(r"\$\{TARGETS\[(\d+)\]\}", replace_indexed_target, command)

        return command

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        written_nodes: set[Path] = set()

        # Note: No explicit mkdir statements needed - Ninja automatically
        # creates output directories before running commands.

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project, written_nodes: set[Path]
    ) -> None:
        """Write build statements for a single target.

        Uses _get_target_build_nodes() to handle both resolved (target-centric)
        and legacy targets uniformly.
        """
        for node in self._get_target_build_nodes(target):
            if node.path not in written_nodes:
                self._write_build_statement(f, node, target, project)
                written_nodes.add(node.path)

    def _write_build_statement(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        project: Project | None = None,
    ) -> None:
        """Write a single build statement.

        Handles both single-output and multi-output builds. Multi-output builds
        use Ninja's implicit output syntax: build out1 out2 | implicit_out: rule deps
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources: list[Node] = build_info.get("sources", [])

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = build_info.get("context") is not None

        # Get the environment for this build (needed for per-env rule naming)
        env = target._env if target else None

        # Check for custom rule name (from generic command builder)
        custom_rule_name = build_info.get("rule_name")
        if custom_rule_name:
            rule_name = custom_rule_name
        else:
            # Rule name must match _ensure_rule() logic
            rule_name = f"{tool_name}_{command_var}"
            if has_effective_reqs:
                # Each env gets its own rule
                env_suffix = self._get_env_suffix(env)
                rule_name += f"_{env_suffix}"

        # Handle multi-output builds from generic commands
        all_targets = build_info.get("all_targets")
        outputs_info = build_info.get("outputs")

        if all_targets and len(cast(list[Node], all_targets)) > 1:
            # Generic command with multiple outputs
            target_nodes = cast(list[FileNode], all_targets)
            output = " ".join(self._escape_output_path(t.path) for t in target_nodes)
        elif outputs_info:
            # Multi-output build (from MultiOutputBuilder)
            explicit_outputs: list[str] = []
            implicit_outputs: list[str] = []

            for _name, info in outputs_info.items():
                path = self._escape_output_path(info["path"])
                if info.get("implicit", False):
                    implicit_outputs.append(path)
                else:
                    explicit_outputs.append(path)

            output = " ".join(explicit_outputs)
            if implicit_outputs:
                output += " | " + " ".join(implicit_outputs)
        else:
            # Single-output build
            output = self._escape_output_path(node.path)

        # Explicit dependencies (sources + library dependencies)
        # For source files, we need to reference them from the build directory
        def get_dep_path(s: FileNode) -> str:
            # Check if this is a build output (has _build_info from resolver)
            # or has a builder (legacy path)
            if getattr(s, "_build_info", None) is not None or s.is_target:
                # Build output - make relative to build dir
                return self._escape_output_path(s.path)

            # Source file - try to make relative with $topdir
            rel = self._make_source_relative(s.path)
            if rel is not None:
                # $topdir is a ninja variable - escape the path part
                return "$topdir/" + self._escape_path(rel)

            # Fall back: escape the path as-is (external files)
            return self._escape_path(s.path)

        # Start with sources from build_info
        explicit_deps_list = [
            get_dep_path(s) for s in sources if isinstance(s, FileNode)
        ]

        # Add any additional explicit deps (e.g., libraries for linking)
        # that aren't already in sources
        source_paths_set = {s.path for s in sources if isinstance(s, FileNode)}
        for dep in node.explicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                # Use _escape_output_path for build outputs (objects, libraries)
                explicit_deps_list.append(self._escape_output_path(dep.path))

        explicit_deps = " ".join(explicit_deps_list)

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_output_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Note: No order-only dependencies for directories needed.
        # Ninja automatically creates output directories before running commands.
        order_only = ""

        f.write(
            f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n"
        )

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info, project)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        build_info: dict[str, object],
        project: Project | None = None,
    ) -> None:
        """Write variables for a build statement.

        For multi-output builds, also writes out_<name> variables for each output.
        For target-centric builds, writes variables from context.get_variables()
        or falls back to effective_* fields for backward compatibility.
        """
        sources: list[Node] = build_info.get("sources", [])  # type: ignore[assignment]

        # Standard variables - handle both source files and build outputs
        def get_source_path(s: FileNode) -> str:
            # Check if this is a build output (has _build_info from resolver)
            # or has a builder (legacy path)
            if getattr(s, "_build_info", None) is not None or s.is_target:
                # Build output - make relative to build dir
                return self._make_output_relative(s.path)

            # Source file - try to make relative with $topdir
            rel = self._make_source_relative(s.path)
            if rel is not None:
                # $topdir is a ninja variable, expanded when used in command
                return f"$topdir/{rel}"

            # Fall back to original path (external files)
            return str(s.path)

        source_file_nodes = [s for s in sources if isinstance(s, FileNode)]
        source_paths = " ".join(get_source_path(s) for s in source_file_nodes)
        if source_paths:
            f.write(f"  in = {source_paths}\n")
        f.write(f"  out = {self._make_output_relative(node.path)}\n")

        # For generic commands with indexed access, write source_N and target_N
        # variables for each source and target
        all_targets = build_info.get("all_targets")
        if all_targets:
            # Write indexed source variables
            for i, src in enumerate(source_file_nodes):
                f.write(f"  source_{i} = {get_source_path(src)}\n")
            # Write indexed target variables
            target_nodes = cast(list[FileNode], all_targets)
            for i, tgt in enumerate(target_nodes):
                f.write(f"  target_{i} = {self._make_output_relative(tgt.path)}\n")

        # For multi-output builds, write out_<name> for each output
        outputs_info = build_info.get("outputs")
        if outputs_info and isinstance(outputs_info, dict):
            for name, info in outputs_info.items():
                # Write out_<name> variable for each output
                if isinstance(info, dict):
                    info_dict = cast(dict[str, Any], info)
                    out_path = self._make_output_relative(info_dict["path"])
                    f.write(f"  out_{name} = {out_path}\n")

        # Write build variables from context (toolchain-specific formatting)
        context = build_info.get("context")
        if context is not None and isinstance(context, ToolchainContext):
            variables = context.get_variables()
            for var_name, var_value in variables.items():
                if var_value:  # Only write non-empty values
                    # var_value is a list of tokens
                    # For includes and libdirs, try to relativize paths
                    if var_name in ("includes", "libdirs"):
                        var_value = [
                            self._relativize_flag_with_path(t) for t in var_value
                        ]
                    # Escape for Ninja variable substitution
                    escaped_tokens = [
                        self._escape_for_ninja_variable(token) for token in var_value
                    ]
                    f.write(f"  {var_name} = {' '.join(escaped_tokens)}\n")

        # Write post-build commands if target has them
        # Check if this is an output node (not an intermediate object file)
        is_output_node = (
            target is not None
            and hasattr(target, "output_nodes")
            and node in target.output_nodes
        )
        # Also check for legacy path where output nodes are in target.nodes
        if not is_output_node and target is not None:
            is_output_node = node in target.nodes

        if is_output_node and target is not None:
            post_build_cmds = getattr(target, "_post_build_commands", [])
            if post_build_cmds:
                # Substitute $out and $in in each command
                out_path = str(node.path)
                in_paths = " ".join(
                    str(s.path) for s in sources if isinstance(s, FileNode)
                )
                substituted_cmds = []
                for cmd in post_build_cmds:
                    cmd = cmd.replace("$out", out_path)
                    cmd = cmd.replace("$in", in_paths)
                    substituted_cmds.append(cmd)
                # Chain commands with && and prepend with &&
                post_build_str = " && " + " && ".join(substituted_cmds)
                f.write(f"  post_build = {post_build_str}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_output_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets."""
        f.write("# Default targets\n")
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            # For resolved targets, use output_nodes
            if target.output_nodes:
                for out_node in target.output_nodes:
                    if isinstance(out_node, FileNode):
                        defaults.append(self._escape_output_path(out_node.path))
            # Fall back to nodes for legacy/unresolved targets
            else:
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        defaults.append(self._escape_output_path(target_node.path))

        # If no default targets, auto-detect "final" outputs
        if not defaults:
            # First, try resolved targets with output nodes
            for target in project.targets:
                if getattr(target, "_resolved", False):
                    # Check if this is a "final" target (program or library)
                    if target.target_type in (
                        "program",
                        "shared_library",
                        "static_library",
                    ):
                        for node in target.output_nodes:
                            if isinstance(node, FileNode):
                                defaults.append(self._escape_output_path(node.path))

            # If still no defaults, use legacy path
            if not defaults:
                for env in project.environments:
                    for node in getattr(env, "_created_nodes", []):
                        if isinstance(node, FileNode) and node.builder is not None:
                            # Check if this is a "final" output (Program, SharedLibrary)
                            build_info = getattr(node, "_build_info", {})
                            tool = build_info.get("tool", "")
                            if tool == "link":
                                defaults.append(self._escape_output_path(node.path))

        if defaults:
            f.write(f"default {' '.join(defaults)}\n")

    def _get_env_suffix(self, env: Environment | None) -> str:
        """Generate a suffix for rule names that identifies the environment.

        Uses the env name if available for readability, plus a unique id
        to ensure different envs get different rules even with the same name.

        Args:
            env: The environment to generate a suffix for.

        Returns:
            A string suffix safe for use in ninja rule names.
        """
        import re

        if env is None:
            return "0"

        parts = []
        # Use env name if available
        if env.name:
            # Sanitize: only allow alphanumeric and underscore
            sanitized = re.sub(r"[^a-zA-Z0-9_]", "_", env.name)
            parts.append(sanitized)

        # Always include id for uniqueness
        parts.append(str(id(env)))

        return "_".join(parts)

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        Always uses forward slashes for cross-platform compatibility.
        """
        path_str = str(path)
        # Normalize to forward slashes (Ninja handles them on all platforms)
        path_str = path_str.replace("\\", "/")
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _make_output_relative(self, path: Path | str) -> str:
        """Make an output path relative to the ninja file location.

        Since the ninja file is written to the build directory, output paths
        should be relative to that directory. For example, if the build dir
        is '/abs/path/build/' and a path is '/abs/path/build/my_program',
        this returns 'my_program'.

        Always uses forward slashes for cross-platform compatibility.
        """
        if self._output_dir is None:
            return str(path).replace("\\", "/")

        path_obj = Path(path)

        # Handle absolute paths
        if path_obj.is_absolute():
            try:
                return str(path_obj.relative_to(self._output_dir)).replace("\\", "/")
            except ValueError:
                # Path is not under output_dir - return as-is
                return str(path).replace("\\", "/")

        # Handle relative paths - try to strip the build dir prefix
        # e.g., "build/my_program" when output_dir is "build"
        build_dir_name = self._output_dir.name
        parts = path_obj.parts
        if parts and parts[0] == build_dir_name:
            # Strip the build dir prefix
            if len(parts) > 1:
                return str(Path(*parts[1:])).replace("\\", "/")
            return "."

        return str(path).replace("\\", "/")

    def _escape_output_path(self, path: Path | str) -> str:
        """Make an output path relative to build dir and escape for Ninja."""
        return self._escape_path(self._make_output_relative(path))

    def _make_source_relative(self, path: Path | str) -> str | None:
        """Try to make a source path relative to project root.

        Returns a path like "src/file.c" (relative to project root) if the path
        is within the project root, or None if it cannot be made relative
        (e.g., path is outside project or on different drive on Windows).

        The caller is responsible for prepending $topdir if needed.
        """
        if self._project_root is None or self._output_dir is None:
            return None

        path_obj = Path(path)

        # Make absolute if relative
        if not path_obj.is_absolute():
            path_obj = self._project_root / path_obj

        path_obj = path_obj.resolve()

        # Try to make path relative to project root
        try:
            rel_to_root = path_obj.relative_to(self._project_root)
            # Use forward slashes for cross-platform compatibility
            return str(rel_to_root).replace("\\", "/")
        except ValueError:
            # Path is not under project root
            return None

    def _relativize_path_for_variable(self, path: str) -> str:
        """Make a path relative for use in ninja variables (like includes).

        For paths within the project, returns $topdir/relative/path.
        For paths outside the project, returns the original path.
        The result is shell-quoted if needed.
        """
        rel = self._make_source_relative(path)
        if rel is not None:
            return rel
        return path

    def _relativize_flag_with_path(self, token: str) -> str:
        """Relativize a compiler flag that contains a path.

        Handles flags like:
        - -I/path/to/include -> -I$topdir/relative/path
        - /I/path/to/include -> /I$topdir/relative/path (MSVC)
        - -L/path/to/lib -> -L$topdir/relative/path
        - /LIBPATH:/path -> /LIBPATH:$topdir/relative/path (MSVC)

        Returns the token unchanged if it's not a path flag or can't be relativized.
        """
        # Common Unix-style flags with path
        for prefix in ("-I", "-L", "-isystem"):
            if token.startswith(prefix):
                path = token[len(prefix) :]
                if path:  # Has a path after the prefix
                    rel = self._make_source_relative(path)
                    if rel is not None:
                        return f"{prefix}$topdir/{rel}"
                return token

        # MSVC-style flags
        if token.startswith("/I"):
            path = token[2:]
            if path:
                rel = self._make_source_relative(path)
                if rel is not None:
                    return f"/I$topdir/{rel}"
            return token

        if token.upper().startswith("/LIBPATH:"):
            prefix = token[:9]  # Preserve original case
            path = token[9:]
            if path:
                rel = self._make_source_relative(path)
                if rel is not None:
                    return f"{prefix}$topdir/{rel}"
            return token

        return token

    def _escape_for_ninja_variable(self, token: str) -> str:
        """Escape a token for use in a Ninja variable value.

        Used for variable values that get substituted into commands.
        Uses Ninja escaping ($ prefix) rather than shell quoting,
        which works consistently across all platforms.

        Ninja escaping: space -> $  (dollar-space), colon -> $:, dollar -> $$
        Also normalizes backslashes to forward slashes for cross-platform paths.

        Preserves Ninja variable references like $topdir, $in, $out.
        """
        # Normalize backslashes to forward slashes
        token = token.replace("\\", "/")

        # Escape special characters for Ninja, but preserve $topdir and other
        # Ninja variables. We do this by temporarily replacing known patterns.
        # $topdir is the main one we use for relative paths.
        token = token.replace("$topdir", "\x00TOPDIR\x00")

        # Escape remaining $ to $$
        token = token.replace("$", "$$")
        token = token.replace(" ", "$ ")
        token = token.replace(":", "$:")

        # Restore $topdir
        token = token.replace("\x00TOPDIR\x00", "$topdir")
        return token

    def _get_rule_command(
        self, env: Environment, builder: Builder, build_info: dict[str, object]
    ) -> str:
        """Get the command for a rule from the environment.

        Expands the command template with environment variables.
        """
        tool_name = str(build_info.get("tool", "unknown"))
        command_var = str(build_info.get("command_var", "cmdline"))

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"echo 'No command template: {tool_name}.{command_var}'"

        # Expand variables using subst() with ninja shell
        # Template can be a string or list of tokens
        # Using shell="ninja" ensures $in, $out aren't quoted
        # Note: $in and $out are left unexpanded for Ninja (they're $$in, $$out in templates)
        return env.subst(command_template, shell="ninja")
