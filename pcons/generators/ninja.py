# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, TextIO

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.builder import Builder
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project, Path("build"))
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        f.write(f"builddir = {self._escape_path(project.build_dir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")

        # Collect all unique rules from targets
        for target in project.targets:
            for node in target.nodes:
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, target)

        f.write("\n")

    def _ensure_rule(self, f: TextIO, node: FileNode, target: Target) -> str:
        """Ensure a rule exists for this node's builder, return rule name."""
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get command template from build info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Create a unique key for this rule based on tool and command var
        rule_key = f"{tool_name}_{command_var}"

        if rule_key not in self._rules:
            # Get the command template from the environment
            # For now, use a placeholder - real implementation will expand from env
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = ${tool_name}_{command_var}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support if this looks like a compiler
            if tool_name in ("cc", "cxx", "cpp"):
                f.write("  depfile = $out.d\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        for target in project.targets:
            self._write_target_builds(f, target, project)

        f.write("\n")

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project
    ) -> None:
        """Write build statements for a single target."""
        for node in target.nodes:
            if isinstance(node, FileNode) and node.builder is not None:
                self._write_build_statement(f, node, target)

    def _write_build_statement(self, f: TextIO, node: FileNode, target: Target) -> None:
        """Write a single build statement."""
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources: list[Node] = build_info.get("sources", [])

        rule_name = f"{tool_name}_{command_var}"
        output = self._escape_path(node.path)

        # Explicit dependencies (sources)
        explicit_deps = " ".join(
            self._escape_path(s.path) for s in sources if isinstance(s, FileNode)
        )

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Order-only dependencies (directories that must exist)
        order_only = ""
        output_dir = node.path.parent
        if output_dir != Path(".") and output_dir != Path(""):
            order_only = f" || {self._escape_path(output_dir)}"

        f.write(f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n")

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target,
        build_info: dict[str, object],
    ) -> None:
        """Write variables for a build statement."""
        sources: list[Node] = build_info.get("sources", [])  # type: ignore[assignment]

        # Standard variables
        source_paths = " ".join(
            str(s.path) for s in sources if isinstance(s, FileNode)
        )
        if source_paths:
            f.write(f"  in = {source_paths}\n")
        f.write(f"  out = {node.path}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets."""
        if not project.default_targets:
            return

        f.write("# Default targets\n")
        defaults: list[str] = []
        for target in project.default_targets:
            for node in target.nodes:
                if isinstance(node, FileNode):
                    defaults.append(self._escape_path(node.path))

        if defaults:
            f.write(f"default {' '.join(defaults)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        """
        path_str = str(path)
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _get_rule_command(
        self, env: Environment, builder: Builder, build_info: dict[str, object]
    ) -> str:
        """Get the command for a rule from the environment.

        Expands the command template with environment variables.
        """
        tool_name = str(build_info.get("tool", "unknown"))
        command_var = str(build_info.get("command_var", "cmdline"))

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"echo 'No command template: {tool_name}.{command_var}'"

        # Expand variables
        # Note: $in and $out are left unexpanded for Ninja
        return env.subst(str(command_template))
