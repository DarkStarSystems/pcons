# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, TextIO

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.builder import Builder
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project, Path("build"))
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        f.write(f"builddir = {self._escape_path(project.build_dir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")

        # Add a rule to create directories (needed for order-only deps)
        f.write("rule mkdir\n")
        f.write("  command = mkdir -p $out\n")
        f.write("  description = MKDIR $out\n")
        f.write("\n")

        # Collect all unique rules from targets
        for target in project.targets:
            # For resolved targets, use object_nodes and output_nodes
            if getattr(target, "_resolved", False):
                env = target._env
                for node in target.object_nodes:
                    self._ensure_rule(f, node, target, env)
                for node in target.output_nodes:
                    self._ensure_rule(f, node, target, env)
            else:
                # Legacy path
                for node in target.nodes:
                    if isinstance(node, FileNode) and node.builder is not None:
                        # Find environment for this target
                        env = self._find_env_for_node(node, project)
                        self._ensure_rule(f, node, target, env)

        # Also check nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, None, env)

        f.write("\n")

    def _find_env_for_node(self, node: FileNode, project: Project) -> Environment | None:
        """Find the environment that created a node."""
        for env in project.environments:
            if node in getattr(env, "_created_nodes", []):
                return env
        return None

    def _ensure_rule(
        self, f: TextIO, node: FileNode, target: Target | None, env: Environment | None = None
    ) -> str:
        """Ensure a rule exists for this node's builder, return rule name.

        For target-centric builds, the rule command may include placeholders
        for effective requirements ($includes, $defines, $extra_flags, etc.)
        that are filled in via per-build variables.
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get command template from build info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = any(
            k.startswith("effective_") for k in build_info.keys()
        )

        # Create a unique key for this rule based on tool, command var, and mode
        rule_key = f"{tool_name}_{command_var}"
        if has_effective_reqs:
            rule_key += "_effective"

        if rule_key not in self._rules:
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Get the actual command from the environment
            command = f"echo 'No command for {rule_key}'"
            if env is not None:
                tool_config = getattr(env, tool_name, None)
                if tool_config is not None:
                    cmd_template = getattr(tool_config, command_var, None)
                    if cmd_template:
                        # Expand tool variables using subst() with ninja shell
                        # Template can be a string or list of tokens
                        # Using shell="ninja" ensures $in, $out aren't quoted
                        # Ninja variables like $in, $out are escaped as $$in, $$out
                        # in the toolchain defaults, and become $in, $out after subst
                        command = env.subst(cmd_template, shell="ninja")

                        # For target-centric builds, append effective requirement
                        # placeholders that will be filled per-build
                        if has_effective_reqs:
                            command = self._augment_command_with_effective_vars(
                                command, command_var
                            )

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = {command}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support based on builder configuration
            depfile = build_info.get("depfile")
            deps_style = build_info.get("deps_style")

            if deps_style == "msvc":
                f.write("  deps = msvc\n")
            elif deps_style == "gcc":
                if depfile:
                    f.write(f"  depfile = {depfile}\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _augment_command_with_effective_vars(
        self, command: str, command_var: str
    ) -> str:
        """Augment a command with effective requirement variables.

        Adds placeholders like $includes, $defines, $extra_flags that will
        be filled in per-build based on the target's effective requirements.

        Args:
            command: The base command template.
            command_var: The command variable name (objcmd, linkcmd, etc.)

        Returns:
            Command with effective requirement placeholders added.
        """
        # For compilation commands (objcmd), add includes, defines, extra_flags
        if command_var == "objcmd":
            # Insert before the output flag (usually -o or -c)
            # We'll append them before the source file
            # Format: cmd $flags $includes $defines $extra_flags -c $in -o $out
            if "$in" in command:
                command = command.replace(
                    "$in",
                    "$includes $defines $extra_flags $in"
                )
        # For link commands (linkcmd, sharedcmd), add ldflags, libdirs, libs
        elif command_var in ("linkcmd", "sharedcmd"):
            # Append link flags at the end
            if "$out" in command:
                # Add after the sources/objects
                command = command.rstrip()
                if not command.endswith("$libs"):
                    command += " $ldflags $libdirs $libs"
        # For archive commands (archivecmd), no changes needed

        return command

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        written_nodes: set[Path] = set()
        written_dirs: set[Path] = set()

        # Collect and write directory build statements first
        self._collect_and_write_directories(f, project, written_dirs)

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _collect_and_write_directories(
        self, f: TextIO, project: Project, written_dirs: set[Path]
    ) -> None:
        """Collect all output directories and write mkdir build statements."""
        directories: set[Path] = set()

        # Collect directories from resolved targets
        for target in project.targets:
            if getattr(target, "_resolved", False):
                for node in target.object_nodes:
                    if isinstance(node, FileNode):
                        parent = node.path.parent
                        if parent != Path(".") and parent != Path(""):
                            directories.add(parent)
                for node in target.output_nodes:
                    if isinstance(node, FileNode):
                        parent = node.path.parent
                        if parent != Path(".") and parent != Path(""):
                            directories.add(parent)
            else:
                for node in target.nodes:
                    if isinstance(node, FileNode):
                        parent = node.path.parent
                        if parent != Path(".") and parent != Path(""):
                            directories.add(parent)

        # Collect directories from environment-tracked nodes
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode):
                    parent = node.path.parent
                    if parent != Path(".") and parent != Path(""):
                        directories.add(parent)

        # Write mkdir statements for each directory
        for directory in sorted(directories):
            if directory not in written_dirs:
                f.write(f"build {self._escape_path(directory)}: mkdir\n")
                written_dirs.add(directory)

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project, written_nodes: set[Path]
    ) -> None:
        """Write build statements for a single target.

        For resolved targets (target._resolved is True), writes builds for
        object_nodes and output_nodes. For legacy targets, uses target.nodes.
        """
        # Check if this is a resolved target (target-centric model)
        if getattr(target, "_resolved", False):
            # Write object file builds
            for node in target.object_nodes:
                if node.path not in written_nodes:
                    self._write_build_statement(f, node, target, project)
                    written_nodes.add(node.path)
            # Write output file builds (library/program)
            for node in target.output_nodes:
                if node.path not in written_nodes:
                    self._write_build_statement(f, node, target, project)
                    written_nodes.add(node.path)
        else:
            # Legacy path: use target.nodes directly
            for node in target.nodes:
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, target, project)
                        written_nodes.add(node.path)

    def _write_build_statement(
        self, f: TextIO, node: FileNode, target: Target | None, project: Project | None = None
    ) -> None:
        """Write a single build statement.

        Handles both single-output and multi-output builds. Multi-output builds
        use Ninja's implicit output syntax: build out1 out2 | implicit_out: rule deps
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources: list[Node] = build_info.get("sources", [])

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = any(
            k.startswith("effective_") for k in build_info.keys()
        )

        rule_name = f"{tool_name}_{command_var}"
        if has_effective_reqs:
            rule_name += "_effective"

        # Handle multi-output builds
        outputs_info = build_info.get("outputs")
        if outputs_info:
            # Multi-output build
            explicit_outputs: list[str] = []
            implicit_outputs: list[str] = []

            for _name, info in outputs_info.items():
                path = self._escape_path(info["path"])
                if info.get("implicit", False):
                    implicit_outputs.append(path)
                else:
                    explicit_outputs.append(path)

            output = " ".join(explicit_outputs)
            if implicit_outputs:
                output += " | " + " ".join(implicit_outputs)
        else:
            # Single-output build
            output = self._escape_path(node.path)

        # Explicit dependencies (sources) - use paths relative to build dir
        # For source files, we need to reference them from the build directory
        def get_source_path(s: FileNode) -> str:
            # If source is in build dir, use relative path
            # Otherwise, make it relative to build dir or absolute
            if project and not s.path.is_absolute():
                # Make path relative from build dir to source dir
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return self._escape_path(src_path)
            return self._escape_path(s.path)

        explicit_deps = " ".join(
            get_source_path(s) for s in sources if isinstance(s, FileNode)
        )

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Order-only dependencies (directories that must exist)
        order_only = ""
        output_dir = node.path.parent
        if output_dir != Path(".") and output_dir != Path(""):
            order_only = f" || {self._escape_path(output_dir)}"

        f.write(f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n")

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info, project)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        build_info: dict[str, object],
        project: Project | None = None,
    ) -> None:
        """Write variables for a build statement.

        For multi-output builds, also writes out_<name> variables for each output.
        For target-centric builds, writes effective_* variables from build_info.
        """
        sources: list[Node] = build_info.get("sources", [])  # type: ignore[assignment]

        # Standard variables - use absolute paths for sources
        def get_source_path(s: FileNode) -> str:
            if project and not s.path.is_absolute():
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return str(src_path)
            return str(s.path)

        source_paths = " ".join(
            get_source_path(s) for s in sources if isinstance(s, FileNode)
        )
        if source_paths:
            f.write(f"  in = {source_paths}\n")
        f.write(f"  out = {node.path}\n")

        # For multi-output builds, write out_<name> for each output
        outputs_info = build_info.get("outputs")
        if outputs_info:
            for name, info in outputs_info.items():  # type: ignore[union-attr]
                # Write out_<name> variable for each output
                f.write(f"  out_{name} = {info['path']}\n")

        # Write effective requirements from target-centric build model
        # These are used to generate the actual compilation/link flags
        effective_includes = build_info.get("effective_includes")
        if effective_includes:
            include_flags = " ".join(f"-I{inc}" for inc in effective_includes)
            f.write(f"  includes = {include_flags}\n")

        effective_defines = build_info.get("effective_defines")
        if effective_defines:
            define_flags = " ".join(f"-D{d}" for d in effective_defines)
            f.write(f"  defines = {define_flags}\n")

        effective_flags = build_info.get("effective_flags")
        if effective_flags:
            flags_str = " ".join(effective_flags)
            f.write(f"  extra_flags = {flags_str}\n")

        # Link-time effective requirements
        effective_link_flags = build_info.get("effective_link_flags")
        if effective_link_flags:
            link_flags_str = " ".join(effective_link_flags)
            f.write(f"  ldflags = {link_flags_str}\n")

        effective_link_libs = build_info.get("effective_link_libs")
        if effective_link_libs:
            libs_str = " ".join(f"-l{lib}" for lib in effective_link_libs)
            f.write(f"  libs = {libs_str}\n")

        effective_link_dirs = build_info.get("effective_link_dirs")
        if effective_link_dirs:
            link_dirs_str = " ".join(f"-L{d}" for d in effective_link_dirs)
            f.write(f"  libdirs = {link_dirs_str}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets."""
        f.write("# Default targets\n")
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            # For resolved targets, use output_nodes
            if getattr(target, "_resolved", False):
                for node in target.output_nodes:
                    if isinstance(node, FileNode):
                        defaults.append(self._escape_path(node.path))
            else:
                for node in target.nodes:
                    if isinstance(node, FileNode):
                        defaults.append(self._escape_path(node.path))

        # If no default targets, auto-detect "final" outputs
        if not defaults:
            # First, try resolved targets with output nodes
            for target in project.targets:
                if getattr(target, "_resolved", False):
                    # Check if this is a "final" target (program or library)
                    if target.target_type in ("program", "shared_library", "static_library"):
                        for node in target.output_nodes:
                            if isinstance(node, FileNode):
                                defaults.append(self._escape_path(node.path))

            # If still no defaults, use legacy path
            if not defaults:
                for env in project.environments:
                    for node in getattr(env, "_created_nodes", []):
                        if isinstance(node, FileNode) and node.builder is not None:
                            # Check if this is a "final" output (Program, SharedLibrary)
                            build_info = getattr(node, "_build_info", {})
                            tool = build_info.get("tool", "")
                            if tool == "link":
                                defaults.append(self._escape_path(node.path))

        if defaults:
            f.write(f"default {' '.join(defaults)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        """
        path_str = str(path)
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _get_rule_command(
        self, env: Environment, builder: Builder, build_info: dict[str, object]
    ) -> str:
        """Get the command for a rule from the environment.

        Expands the command template with environment variables.
        """
        tool_name = str(build_info.get("tool", "unknown"))
        command_var = str(build_info.get("command_var", "cmdline"))

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"echo 'No command template: {tool_name}.{command_var}'"

        # Expand variables using subst() with ninja shell
        # Template can be a string or list of tokens
        # Using shell="ninja" ensures $in, $out aren't quoted
        # Note: $in and $out are left unexpanded for Ninja (they're $$in, $$out in templates)
        return env.subst(command_template, shell="ninja")
