# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, Any, TextIO, cast

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.builder import Builder
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project, Path("build"))
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        f.write(f"builddir = {self._escape_path(project.build_dir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")
        # Note: Ninja automatically creates output directories before running
        # commands, so we don't need explicit mkdir rules.

        # Collect all unique rules from targets
        for target in project.targets:
            env = target._env
            for node in self._get_target_build_nodes(target, project):
                self._ensure_rule(f, node, target, env)

        # Also check nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, None, env)

        f.write("\n")

    def _get_target_build_nodes(
        self, target: Target, project: Project
    ) -> list[FileNode]:
        """Get all buildable file nodes from a target.

        This is a helper method that handles both resolved (target-centric)
        and legacy targets, extracting nodes that have build information.

        Args:
            target: The target to get nodes from.
            project: The project (used for legacy path to find environment).

        Returns:
            List of FileNodes that have build information.
        """
        nodes: list[FileNode] = []

        if getattr(target, "_resolved", False):
            # Resolved target (target-centric model)
            # Add object nodes and output nodes
            for obj_node in target.object_nodes:
                if isinstance(obj_node, FileNode):
                    nodes.append(obj_node)
            for out_node in target.output_nodes:
                if isinstance(out_node, FileNode):
                    nodes.append(out_node)
            # For interface targets (like Install), also check target.nodes
            if target.target_type == "interface":
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        has_build = (
                            getattr(target_node, "_build_info", None) is not None
                        )
                        if has_build:
                            nodes.append(target_node)
        else:
            # Legacy path: use target.nodes directly
            for target_node in target.nodes:
                # Check for builder or build_info (install nodes use build_info)
                has_build = (
                    target_node.builder is not None
                    or getattr(target_node, "_build_info", None) is not None
                )
                if isinstance(target_node, FileNode) and has_build:
                    nodes.append(target_node)

        return nodes

    def _find_env_for_node(
        self, node: FileNode, project: Project
    ) -> Environment | None:
        """Find the environment that created a node."""
        for env in project.environments:
            if node in getattr(env, "_created_nodes", []):
                return env
        return None

    def _ensure_rule(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        env: Environment | None = None,
    ) -> str:
        """Ensure a rule exists for this node's builder, return rule name.

        For target-centric builds, the rule command may include placeholders
        for effective requirements ($includes, $defines, $extra_flags, etc.)
        that are filled in via per-build variables.
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get command template from build info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = any(k.startswith("effective_") for k in build_info.keys())

        # Check if this is a generic command (has custom rule_name and command)
        custom_rule_name = build_info.get("rule_name")
        custom_command = build_info.get("command")

        # Create a unique key for this rule based on tool, command var, and mode
        if custom_rule_name:
            # Generic command builder uses custom rule name
            rule_key = custom_rule_name
        else:
            rule_key = f"{tool_name}_{command_var}"
            if has_effective_reqs:
                rule_key += "_effective"

        if rule_key not in self._rules:
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Get the actual command from the environment or build_info
            command = f"echo 'No command for {rule_key}'"

            # Special case for copy command (from Install) - check this BEFORE
            # generic command since Install also sets a "command" field
            if tool_name == "copy":
                copy_cmd = build_info.get("copy_cmd", "cp $in $out")
                command = copy_cmd + "$post_build"
                description = "INSTALL $out"
            # Special case for lipo (universal binary creation on macOS)
            elif tool_name == "lipo":
                command = "lipo -create -output $out $in"
                description = "LIPO $out"
            # Archive builders (Tarfile, Zipfile)
            # Use sys.executable (Python that ran pcons) with the standalone helper script
            elif tool_name == "tarfile":
                import sys

                import pcons.util.archive_helper as archive_mod

                compression = build_info.get("compression")
                base_dir = build_info.get("base_dir", ".")
                compression_flag = f"--compression {compression}" if compression else ""
                helper_path = Path(archive_mod.__file__)  # type: ignore[arg-type]
                command = (
                    f"{sys.executable} {helper_path} --type tar "
                    f"{compression_flag} --output $out --base-dir {base_dir} $in"
                )
                description = "TAR $out"
            elif tool_name == "zipfile":
                import sys

                import pcons.util.archive_helper as archive_mod

                base_dir = build_info.get("base_dir", ".")
                helper_path = Path(archive_mod.__file__)  # type: ignore[arg-type]
                command = (
                    f"{sys.executable} {helper_path} --type zip "
                    f"--output $out --base-dir {base_dir} $in"
                )
                description = "ZIP $out"
            # Check for generic command builder (has custom command in build_info)
            elif custom_command:
                # Generic command builder - use the command directly
                # Convert $SOURCE, $TARGET etc. to Ninja $in, $out
                command = self._convert_command_variables(custom_command)
                description = "COMMAND $out"
            elif env is not None:
                tool_config = getattr(env, tool_name, None)
                if tool_config is not None:
                    cmd_template = getattr(tool_config, command_var, None)
                    if cmd_template:
                        # Expand tool variables using subst() with ninja shell
                        # Template can be a string or list of tokens
                        # Using shell="ninja" ensures $in, $out aren't quoted
                        # Ninja variables like $in, $out are escaped as $$in, $$out
                        # in the toolchain defaults, and become $in, $out after subst
                        command = env.subst(cmd_template, shell="ninja")

                        # For target-centric builds, append effective requirement
                        # placeholders that will be filled per-build
                        if has_effective_reqs:
                            command = self._augment_command_with_effective_vars(
                                command, command_var
                            )
                        else:
                            # For non-effective builds, still add $post_build
                            command = command.rstrip() + "$post_build"

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = {command}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support based on builder configuration
            depfile = build_info.get("depfile")
            deps_style = build_info.get("deps_style")

            if deps_style == "msvc":
                f.write("  deps = msvc\n")
            elif deps_style == "gcc":
                if depfile:
                    f.write(f"  depfile = {depfile}\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _augment_command_with_effective_vars(
        self, command: str, command_var: str
    ) -> str:
        """Augment a command with effective requirement variables.

        Adds placeholders like $includes, $defines, $extra_flags that will
        be filled in per-build based on the target's effective requirements.

        Args:
            command: The base command template.
            command_var: The command variable name (objcmd, linkcmd, etc.)

        Returns:
            Command with effective requirement placeholders added.
        """
        # For compilation commands (objcmd), add includes, defines, extra_flags
        if command_var == "objcmd":
            # Insert before the output flag (usually -o or -c)
            # We'll append them before the source file
            # Format: cmd $flags $includes $defines $extra_flags -c $in -o $out
            if "$in" in command:
                command = command.replace("$in", "$includes $defines $extra_flags $in")
        # For link commands (linkcmd, sharedcmd, progcmd), add ldflags, libdirs, libs
        elif command_var in ("linkcmd", "sharedcmd", "progcmd"):
            # Append link flags at the end
            if "$out" in command:
                # Add after the sources/objects
                command = command.rstrip()
                if not command.endswith("$libs"):
                    command += " $ldflags $libdirs $libs"
        # For archive commands (archivecmd), no changes needed

        # For all commands, append $post_build placeholder for post-build commands
        # This will be empty unless a target has post_build commands
        command = command.rstrip() + "$post_build"

        return command

    def _convert_command_variables(self, command: str) -> str:
        """Convert env.Command() variables to Ninja variables.

        Converts SCons-style variables to Ninja-style:
        - $SOURCE, $SOURCES -> $in
        - $TARGET, $TARGETS -> $out
        - ${SOURCES[n]} -> indexed source (handled at build time)
        - ${TARGETS[n]} -> indexed target (handled at build time)

        Args:
            command: The command template with SCons-style variables.

        Returns:
            Command with Ninja-style variables.
        """
        import re

        # Convert plural forms first (so they don't match singular)
        command = command.replace("$SOURCES", "$in")
        command = command.replace("$TARGETS", "$out")

        # Convert singular forms
        command = command.replace("$SOURCE", "$in")
        command = command.replace("$TARGET", "$out")

        # Handle indexed access ${SOURCES[n]} and ${TARGETS[n]}
        # These need special handling - we'll convert to per-build variables
        # that will be filled in by _write_build_variables
        def replace_indexed_source(match: re.Match[str]) -> str:
            index = match.group(1)
            return f"$source_{index}"

        def replace_indexed_target(match: re.Match[str]) -> str:
            index = match.group(1)
            return f"$target_{index}"

        command = re.sub(r"\$\{SOURCES\[(\d+)\]\}", replace_indexed_source, command)
        command = re.sub(r"\$\{TARGETS\[(\d+)\]\}", replace_indexed_target, command)

        return command

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        written_nodes: set[Path] = set()

        # Note: No explicit mkdir statements needed - Ninja automatically
        # creates output directories before running commands.

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project, written_nodes: set[Path]
    ) -> None:
        """Write build statements for a single target.

        Uses _get_target_build_nodes() to handle both resolved (target-centric)
        and legacy targets uniformly.
        """
        for node in self._get_target_build_nodes(target, project):
            if node.path not in written_nodes:
                self._write_build_statement(f, node, target, project)
                written_nodes.add(node.path)

    def _write_build_statement(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        project: Project | None = None,
    ) -> None:
        """Write a single build statement.

        Handles both single-output and multi-output builds. Multi-output builds
        use Ninja's implicit output syntax: build out1 out2 | implicit_out: rule deps
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources: list[Node] = build_info.get("sources", [])

        # Check if this is a target-centric build (has effective requirements)
        has_effective_reqs = any(k.startswith("effective_") for k in build_info.keys())

        # Check for custom rule name (from generic command builder)
        custom_rule_name = build_info.get("rule_name")
        if custom_rule_name:
            rule_name = custom_rule_name
        else:
            rule_name = f"{tool_name}_{command_var}"
            if has_effective_reqs:
                rule_name += "_effective"

        # Handle multi-output builds from generic commands
        all_targets = build_info.get("all_targets")
        outputs_info = build_info.get("outputs")

        if all_targets and len(cast(list[Node], all_targets)) > 1:
            # Generic command with multiple outputs
            target_nodes = cast(list[FileNode], all_targets)
            output = " ".join(self._escape_path(t.path) for t in target_nodes)
        elif outputs_info:
            # Multi-output build (from MultiOutputBuilder)
            explicit_outputs: list[str] = []
            implicit_outputs: list[str] = []

            for _name, info in outputs_info.items():
                path = self._escape_path(info["path"])
                if info.get("implicit", False):
                    implicit_outputs.append(path)
                else:
                    explicit_outputs.append(path)

            output = " ".join(explicit_outputs)
            if implicit_outputs:
                output += " | " + " ".join(implicit_outputs)
        else:
            # Single-output build
            output = self._escape_path(node.path)

        # Explicit dependencies (sources + library dependencies)
        # For source files, we need to reference them from the build directory
        def get_source_path(s: FileNode) -> str:
            # If source is in build dir, use relative path
            # Otherwise, make it relative to build dir or absolute
            if project and not s.path.is_absolute():
                # Make path relative from build dir to source dir
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return self._escape_path(src_path)
            return self._escape_path(s.path)

        # Start with sources from build_info
        explicit_deps_list = [
            get_source_path(s) for s in sources if isinstance(s, FileNode)
        ]

        # Add any additional explicit deps (e.g., libraries for linking)
        # that aren't already in sources
        source_paths_set = {s.path for s in sources if isinstance(s, FileNode)}
        for dep in node.explicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                explicit_deps_list.append(self._escape_path(dep.path))

        explicit_deps = " ".join(explicit_deps_list)

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Note: No order-only dependencies for directories needed.
        # Ninja automatically creates output directories before running commands.
        order_only = ""

        f.write(
            f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n"
        )

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info, project)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        build_info: dict[str, object],
        project: Project | None = None,
    ) -> None:
        """Write variables for a build statement.

        For multi-output builds, also writes out_<name> variables for each output.
        For target-centric builds, writes effective_* variables from build_info.
        """
        sources: list[Node] = build_info.get("sources", [])  # type: ignore[assignment]

        # Standard variables - use absolute paths for sources
        def get_source_path(s: FileNode) -> str:
            if project and not s.path.is_absolute():
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return str(src_path)
            return str(s.path)

        source_file_nodes = [s for s in sources if isinstance(s, FileNode)]
        source_paths = " ".join(get_source_path(s) for s in source_file_nodes)
        if source_paths:
            f.write(f"  in = {source_paths}\n")
        f.write(f"  out = {node.path}\n")

        # For generic commands with indexed access, write source_N and target_N
        # variables for each source and target
        all_targets = build_info.get("all_targets")
        if all_targets:
            # Write indexed source variables
            for i, src in enumerate(source_file_nodes):
                f.write(f"  source_{i} = {get_source_path(src)}\n")
            # Write indexed target variables
            target_nodes = cast(list[FileNode], all_targets)
            for i, tgt in enumerate(target_nodes):
                f.write(f"  target_{i} = {tgt.path}\n")

        # For multi-output builds, write out_<name> for each output
        outputs_info = build_info.get("outputs")
        if outputs_info and isinstance(outputs_info, dict):
            for name, info in outputs_info.items():
                # Write out_<name> variable for each output
                if isinstance(info, dict):
                    info_dict = cast(dict[str, Any], info)
                    f.write(f"  out_{name} = {info_dict['path']}\n")

        # Write effective requirements from target-centric build model
        # These are used to generate the actual compilation/link flags
        effective_includes = build_info.get("effective_includes")
        if effective_includes and isinstance(effective_includes, list):
            include_flags = " ".join(f"-I{inc}" for inc in effective_includes)
            f.write(f"  includes = {include_flags}\n")

        effective_defines = build_info.get("effective_defines")
        if effective_defines and isinstance(effective_defines, list):
            define_flags = " ".join(f"-D{d}" for d in effective_defines)
            f.write(f"  defines = {define_flags}\n")

        effective_flags = build_info.get("effective_flags")
        if effective_flags and isinstance(effective_flags, list):
            flags_str = " ".join(str(f) for f in effective_flags)
            f.write(f"  extra_flags = {flags_str}\n")

        # Link-time effective requirements
        effective_link_flags = build_info.get("effective_link_flags")
        if effective_link_flags and isinstance(effective_link_flags, list):
            link_flags_str = " ".join(str(f) for f in effective_link_flags)
            f.write(f"  ldflags = {link_flags_str}\n")

        effective_link_libs = build_info.get("effective_link_libs")
        if effective_link_libs and isinstance(effective_link_libs, list):
            libs_str = " ".join(f"-l{lib}" for lib in effective_link_libs)
            f.write(f"  libs = {libs_str}\n")

        effective_link_dirs = build_info.get("effective_link_dirs")
        if effective_link_dirs and isinstance(effective_link_dirs, list):
            link_dirs_str = " ".join(f"-L{d}" for d in effective_link_dirs)
            f.write(f"  libdirs = {link_dirs_str}\n")

        # Write post-build commands if target has them
        # Check if this is an output node (not an intermediate object file)
        is_output_node = (
            target is not None
            and hasattr(target, "output_nodes")
            and node in target.output_nodes
        )
        # Also check for legacy path where output nodes are in target.nodes
        if not is_output_node and target is not None:
            is_output_node = node in target.nodes

        if is_output_node and target is not None:
            post_build_cmds = getattr(target, "_post_build_commands", [])
            if post_build_cmds:
                # Substitute $out and $in in each command
                out_path = str(node.path)
                in_paths = " ".join(
                    str(s.path) for s in sources if isinstance(s, FileNode)
                )
                substituted_cmds = []
                for cmd in post_build_cmds:
                    cmd = cmd.replace("$out", out_path)
                    cmd = cmd.replace("$in", in_paths)
                    substituted_cmds.append(cmd)
                # Chain commands with && and prepend with &&
                post_build_str = " && " + " && ".join(substituted_cmds)
                f.write(f"  post_build = {post_build_str}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets."""
        f.write("# Default targets\n")
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            # For resolved targets, use output_nodes
            if target.output_nodes:
                for out_node in target.output_nodes:
                    if isinstance(out_node, FileNode):
                        defaults.append(self._escape_path(out_node.path))
            # Fall back to nodes for legacy/unresolved targets
            else:
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        defaults.append(self._escape_path(target_node.path))

        # If no default targets, auto-detect "final" outputs
        if not defaults:
            # First, try resolved targets with output nodes
            for target in project.targets:
                if getattr(target, "_resolved", False):
                    # Check if this is a "final" target (program or library)
                    if target.target_type in (
                        "program",
                        "shared_library",
                        "static_library",
                    ):
                        for node in target.output_nodes:
                            if isinstance(node, FileNode):
                                defaults.append(self._escape_path(node.path))

            # If still no defaults, use legacy path
            if not defaults:
                for env in project.environments:
                    for node in getattr(env, "_created_nodes", []):
                        if isinstance(node, FileNode) and node.builder is not None:
                            # Check if this is a "final" output (Program, SharedLibrary)
                            build_info = getattr(node, "_build_info", {})
                            tool = build_info.get("tool", "")
                            if tool == "link":
                                defaults.append(self._escape_path(node.path))

        if defaults:
            f.write(f"default {' '.join(defaults)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        """
        path_str = str(path)
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _get_rule_command(
        self, env: Environment, builder: Builder, build_info: dict[str, object]
    ) -> str:
        """Get the command for a rule from the environment.

        Expands the command template with environment variables.
        """
        tool_name = str(build_info.get("tool", "unknown"))
        command_var = str(build_info.get("command_var", "cmdline"))

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"echo 'No command template: {tool_name}.{command_var}'"

        # Expand variables using subst() with ninja shell
        # Template can be a string or list of tokens
        # Using shell="ninja" ensures $in, $out aren't quoted
        # Note: $in and $out are left unexpanded for Ninja (they're $$in, $$out in templates)
        return env.subst(command_template, shell="ninja")
