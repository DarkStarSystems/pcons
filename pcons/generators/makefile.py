# SPDX-License-Identifier: MIT
"""GNU Makefile generator for pcons.

Generates Makefiles from a configured pcons Project.
Requires GNU Make 3.80+ for order-only prerequisites.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, TextIO

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class MakefileGenerator(BaseGenerator):
    """Generator that produces GNU Makefiles.

    Generates a complete Makefile including:
    - Variable definitions
    - Directory creation rules
    - Build rules with dependencies
    - Phony targets for aliases
    - Default target
    - Depfile includes for incremental builds
    - Clean target

    Note: Requires GNU Make 3.80+ for order-only prerequisites.

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = MakefileGenerator()
        generator.generate(project, Path("build"))
        # Creates build/Makefile
    """

    # Characters that need escaping in Makefiles
    # $ -> $$, # -> \#, spaces in targets need escaping
    ESCAPE_DOLLAR = re.compile(r"\$")

    def __init__(self) -> None:
        super().__init__("makefile")
        self._directories: set[Path] = set()
        self._depfile_dirs: set[Path] = set()
        self._project_root: Path | None = None

    def _generate_impl(self, project: Project, output_dir: Path) -> None:
        """Generate Makefile.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write Makefile to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        makefile_path = output_dir / "Makefile"

        # Reset state for this generation
        self._directories = set()
        self._depfile_dirs = set()
        self._project_root = project.root_dir.resolve()

        with open(makefile_path, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project, output_dir)
            self._write_phony_declaration(f, project)
            self._collect_directories(project)
            self._write_directory_rules(f)
            self._write_build_rules(f, project)
            self._write_aliases(f, project)
            self._write_default_target(f, project)
            self._write_depfile_includes(f)
            self._write_clean_target(f, output_dir)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("\n")
        # Disable built-in rules for cleaner output and faster make
        f.write("# Disable built-in rules\n")
        f.write(".SUFFIXES:\n")
        f.write("MAKEFLAGS += --no-builtin-rules\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project, output_dir: Path) -> None:
        """Write global variables."""
        f.write("# Variables\n")
        f.write(f"BUILDDIR := {self._escape_path(output_dir)}\n")
        f.write("\n")

    def _write_phony_declaration(self, f: TextIO, project: Project) -> None:
        """Write .PHONY declaration for all phony targets."""
        phony_targets = ["all", "clean"]

        # Add aliases
        for name in project.aliases.keys():
            phony_targets.append(name)

        f.write("# Phony targets\n")
        f.write(f".PHONY: {' '.join(phony_targets)}\n")
        f.write("\n")

    def _collect_directories(self, project: Project) -> None:
        """Collect all directories that need to be created."""
        # Collect from targets
        for target in project.targets:
            for node in self._get_target_build_nodes(target):
                parent = node.path.parent
                if parent != Path(".") and parent != Path(""):
                    self._directories.add(parent)
                # Track depfile directories
                build_info = getattr(node, "_build_info", None) or {}
                if build_info.get("depfile"):
                    depfile = Path(build_info["depfile"])
                    self._depfile_dirs.add(depfile.parent)

        # Collect from environment-tracked nodes
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode):
                    parent = node.path.parent
                    if parent != Path(".") and parent != Path(""):
                        self._directories.add(parent)

    def _write_directory_rules(self, f: TextIO) -> None:
        """Write rules to create directories."""
        if not self._directories:
            return

        f.write("# Directory creation\n")
        for directory in sorted(self._directories):
            escaped = self._escape_path(directory)
            f.write(f"{escaped}:\n")
            f.write("\tmkdir -p $@\n")
            f.write("\n")

    def _write_build_rules(self, f: TextIO, project: Project) -> None:
        """Write all build rules."""
        f.write("# Build rules\n")
        written_nodes: set[Path] = set()

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_rule(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _write_target_builds(
        self,
        f: TextIO,
        target: Target,
        project: Project,
        written_nodes: set[Path],
    ) -> None:
        """Write build rules for a single target."""
        for node in self._get_target_build_nodes(target):
            if node.path not in written_nodes:
                self._write_build_rule(f, node, target, project)
                written_nodes.add(node.path)

    def _write_build_rule(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        project: Project,
    ) -> None:
        """Write a single build rule."""
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        sources: list[Node] = build_info.get("sources", [])

        # Handle multi-output builds
        outputs_info = build_info.get("outputs")
        if outputs_info:
            # Multi-output build - list all outputs
            all_outputs = [
                self._escape_path(info["path"]) for info in outputs_info.values()
            ]
            output = " ".join(all_outputs)
        else:
            output = self._escape_path(node.path)

        # Get source paths - use PathResolver for consistent handling
        # Makefile can run from either project root or build directory (via make -C),
        # so we use absolute paths for source files to work in both cases.
        def get_source_path(s: FileNode) -> str:
            # Check if this is a build output (has _build_info from resolver)
            if getattr(s, "_build_info", None) is not None or s.is_target:
                # Build output - path already includes build_dir prefix
                return self._escape_path(s.path)

            # Source file - make absolute using project root
            # This ensures the path works whether make runs from project root or build dir
            path_obj = s.path
            if not path_obj.is_absolute() and self._project_root is not None:
                path_obj = self._project_root / path_obj
            return self._escape_path(path_obj)

        # Build list of prerequisites
        prereqs: list[str] = []

        # Add sources
        for s in sources:
            if isinstance(s, FileNode):
                prereqs.append(get_source_path(s))

        # Add explicit deps (e.g., libraries for linking)
        source_paths_set = {s.path for s in sources if isinstance(s, FileNode)}
        for dep in node.explicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                prereqs.append(self._escape_path(dep.path))

        # Add implicit deps (e.g., headers discovered by scanners)
        for dep in node.implicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                prereqs.append(self._escape_path(dep.path))

        # Order-only prerequisites (directories)
        order_only: list[str] = []
        output_dir = node.path.parent
        if output_dir != Path(".") and output_dir != Path(""):
            order_only.append(self._escape_path(output_dir))

        # Build the target line
        prereq_str = " ".join(prereqs)
        if order_only:
            order_only_str = " | " + " ".join(order_only)
        else:
            order_only_str = ""

        f.write(f"{output}: {prereq_str}{order_only_str}\n")

        # Write the command
        command = self._get_command(node, target, project, sources)
        if command:
            f.write(f"\t{command}\n")

        f.write("\n")

    def _get_command(
        self,
        node: FileNode,
        target: Target | None,
        project: Project,
        sources: list[Node],
    ) -> str:
        """Get the build command for a node."""
        build_info = getattr(node, "_build_info", {})
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Get the environment from target
        env: Environment | None = None
        if target is not None:
            env = getattr(target, "_env", None)

        if env is None:
            # Try to find from project environments
            for e in project.environments:
                if node in getattr(e, "_created_nodes", []):
                    env = e
                    break

        # Check for command in build_info first (generic commands, install, archive)
        # This covers: Install, InstallAs, InstallDir, Tarfile, Zipfile, lipo, and
        # any custom builder that sets command in _build_info
        custom_command = build_info.get("command")
        if custom_command:
            # Builder provided command directly - use it
            # Command can be a list of tokens or a string
            if isinstance(custom_command, list):
                # Process PathToken objects (Makefile runs from project root,
                # so paths relative to project root don't need transformation)
                processed_tokens = self._process_path_tokens(custom_command)
                # Convert token list to shell command with proper quoting
                from pcons.core.subst import to_shell_command

                command = to_shell_command(processed_tokens, shell="bash")
            else:
                command = str(custom_command)
            # Convert $SOURCE, $TARGET etc. to make variables
            command = self._convert_command_variables(command)
            command = self._substitute_make_vars(command, node, sources, build_info)
            return self._append_post_build(command, node, target, sources)

        if env is None:
            return f"@echo 'No environment for {node.path}'"

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            return f"@echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"@echo 'No command template: {tool_name}.{command_var}'"

        # Expand the command template
        command = env.subst(command_template, shell="posix")

        # Substitute $in, $out with Make automatic variables
        command = self._substitute_make_vars(command, node, sources, build_info)

        # Append post-build commands if any
        command = self._append_post_build(command, node, target, sources)

        return command

    def _append_post_build(
        self,
        command: str,
        node: FileNode,
        target: Target | None,
        sources: list[Node],
    ) -> str:
        """Append post-build commands to the main command."""
        if target is None:
            return command

        # Check if this is an output node (not an intermediate object file)
        is_output_node = hasattr(target, "output_nodes") and node in target.output_nodes
        # Also check output nodes in target.nodes (for interface targets like Install)
        if not is_output_node:
            is_output_node = node in target.nodes

        if not is_output_node:
            return command

        post_build_cmds = getattr(target, "_post_build_commands", [])
        if not post_build_cmds:
            return command

        # Substitute $out and $in in each command
        out_path = str(node.path)
        in_paths = " ".join(str(s.path) for s in sources if isinstance(s, FileNode))

        substituted_cmds = []
        for cmd in post_build_cmds:
            cmd = cmd.replace("$out", out_path)
            cmd = cmd.replace("$in", in_paths)
            substituted_cmds.append(cmd)

        # Chain commands with &&
        return command + " && " + " && ".join(substituted_cmds)

    def _quote_tokens_for_make(self, tokens: list[str]) -> str:
        """Quote and join tokens for use in Makefile shell commands.

        Handles:
        - Shell quoting for tokens with spaces or special characters
        - Escaping $ as $$ for Make
        """
        if not tokens:
            return ""

        quoted = []
        for token in tokens:
            # Escape $ as $$ for Make (must be done first)
            escaped = token.replace("$", "$$")
            # Shell quote if needed (spaces, special chars)
            if self._needs_shell_quote(escaped):
                # Use single quotes, but handle existing single quotes
                if "'" not in escaped:
                    escaped = f"'{escaped}'"
                else:
                    # Escape for double quotes
                    escaped = escaped.replace("\\", "\\\\")
                    escaped = escaped.replace('"', '\\"')
                    escaped = escaped.replace("`", "\\`")
                    escaped = f'"{escaped}"'
            quoted.append(escaped)
        return " ".join(quoted)

    def _needs_shell_quote(self, s: str) -> bool:
        """Check if a string needs shell quoting."""
        if not s:
            return True
        # Characters that trigger quoting
        return any(c in s for c in " \t\n\"'\\`!*?[](){}|&;<>")

    def _substitute_make_vars(
        self,
        command: str,
        node: FileNode,
        sources: list[Node],
        build_info: dict[str, object],
    ) -> str:
        """Substitute $in/$out with actual paths (not Make automatic vars).

        We use explicit paths rather than $< and $@ because the sources
        may not match Make's automatic variable semantics exactly.
        """
        # Get source paths
        source_paths = " ".join(str(s.path) for s in sources if isinstance(s, FileNode))

        # Substitute $in and $out
        command = command.replace("$in", source_paths)
        command = command.replace("$out", str(node.path))

        # Handle depfile if present
        depfile = build_info.get("depfile")
        if depfile:
            command = command.replace("$out.d", str(depfile))

        return command

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write alias targets."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"{name}: {targets}\n")
        f.write("\n")

    def _write_default_target(self, f: TextIO, project: Project) -> None:
        """Write the default target."""
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            if target.output_nodes:
                for out_node in target.output_nodes:
                    if isinstance(out_node, FileNode):
                        defaults.append(self._escape_path(out_node.path))
            else:
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        defaults.append(self._escape_path(target_node.path))

        # If no default targets, auto-detect
        if not defaults:
            for target in project.targets:
                if getattr(target, "_resolved", False):
                    if target.target_type in (
                        "program",
                        "shared_library",
                        "static_library",
                    ):
                        for node in target.output_nodes:
                            if isinstance(node, FileNode):
                                defaults.append(self._escape_path(node.path))

        if defaults:
            f.write("# Default target\n")
            f.write(f"all: {' '.join(defaults)}\n")
            f.write(".DEFAULT_GOAL := all\n")
            f.write("\n")

    def _write_depfile_includes(self, f: TextIO) -> None:
        """Write includes for dependency files."""
        if not self._directories:
            return

        f.write("# Include dependency files (generated by compiler -MD flag)\n")
        # Include .d files from all directories that might have objects
        for directory in sorted(self._directories):
            f.write(f"-include {self._escape_path(directory)}/*.d\n")
        f.write("\n")

    def _write_clean_target(self, f: TextIO, output_dir: Path) -> None:
        """Write the clean target."""
        f.write("# Clean target\n")
        f.write("clean:\n")
        f.write(f"\trm -rf {self._escape_path(output_dir)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Makefiles.

        In Makefiles, $ must be escaped as $$. Spaces are tricky
        and generally should be avoided in build paths.
        """
        path_str = str(path)
        # Escape $ as $$
        return self.ESCAPE_DOLLAR.sub("$$", path_str)

    def _process_path_tokens(self, tokens: list) -> list[str]:
        """Process PathToken objects in a command token list.

        Since Makefile runs from the project root, paths relative to project
        root don't need transformation. PathToken objects are converted to
        their string representation (prefix + path).

        Args:
            tokens: List of command tokens (str or PathToken).

        Returns:
            List of string tokens.
        """
        from pcons.core.subst import PathToken

        result: list[str] = []
        for token in tokens:
            if isinstance(token, PathToken):
                # For Makefile, paths relative to project root stay as-is
                # Just convert PathToken to string (prefix + path)
                result.append(str(token))
            else:
                result.append(str(token))
        return result

    def _convert_command_variables(self, command: str) -> str:
        """Convert env.Command() variables to Make-compatible variables.

        Converts SCons-style variables:
        - $SOURCE, $SOURCES -> $in
        - $TARGET, $TARGETS -> $out
        - ${SOURCES[n]} -> indexed source (handled later)
        - ${TARGETS[n]} -> indexed target (handled later)

        Args:
            command: The command template with SCons-style variables.

        Returns:
            Command with Make-compatible variables.
        """
        # Convert plural forms first (so they don't match singular)
        command = command.replace("$SOURCES", "$in")
        command = command.replace("$TARGETS", "$out")

        # Convert singular forms
        command = command.replace("$SOURCE", "$in")
        command = command.replace("$TARGET", "$out")

        # Handle indexed access ${SOURCES[n]} and ${TARGETS[n]}
        # These need special handling - for now, expand to all sources/targets
        # (Makefile doesn't have a direct equivalent for indexed access)
        import re

        command = re.sub(r"\$\{SOURCES\[\d+\]\}", "$in", command)
        command = re.sub(r"\$\{TARGETS\[\d+\]\}", "$out", command)

        return command
