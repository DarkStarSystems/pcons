# SPDX-License-Identifier: MIT
"""GNU Makefile generator for pcons.

Generates Makefiles from a configured pcons Project.
Requires GNU Make 3.80+ for order-only prerequisites.
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, TextIO

from pcons.core.node import FileNode, Node
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.target import Target


class MakefileGenerator(BaseGenerator):
    """Generator that produces GNU Makefiles.

    Generates a complete Makefile including:
    - Variable definitions
    - Directory creation rules
    - Build rules with dependencies
    - Phony targets for aliases
    - Default target
    - Depfile includes for incremental builds
    - Clean target

    Note: Requires GNU Make 3.80+ for order-only prerequisites.

    Example:
        project = Project("myapp")
        # ... configure project ...

        generator = MakefileGenerator()
        generator.generate(project, Path("build"))
        # Creates build/Makefile
    """

    # Characters that need escaping in Makefiles
    # $ -> $$, # -> \#, spaces in targets need escaping
    ESCAPE_DOLLAR = re.compile(r"\$")

    def __init__(self) -> None:
        super().__init__("makefile")
        self._directories: set[Path] = set()
        self._depfile_dirs: set[Path] = set()

    def generate(self, project: Project, output_dir: Path) -> None:
        """Generate Makefile.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write Makefile to.
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        makefile_path = output_dir / "Makefile"

        # Reset state for this generation
        self._directories = set()
        self._depfile_dirs = set()

        with open(makefile_path, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project, output_dir)
            self._write_phony_declaration(f, project)
            self._collect_directories(project)
            self._write_directory_rules(f)
            self._write_build_rules(f, project)
            self._write_aliases(f, project)
            self._write_default_target(f, project)
            self._write_depfile_includes(f)
            self._write_clean_target(f, output_dir)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("\n")
        # Disable built-in rules for cleaner output and faster make
        f.write("# Disable built-in rules\n")
        f.write(".SUFFIXES:\n")
        f.write("MAKEFLAGS += --no-builtin-rules\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project, output_dir: Path) -> None:
        """Write global variables."""
        f.write("# Variables\n")
        f.write(f"BUILDDIR := {self._escape_path(output_dir)}\n")
        f.write("\n")

    def _write_phony_declaration(self, f: TextIO, project: Project) -> None:
        """Write .PHONY declaration for all phony targets."""
        phony_targets = ["all", "clean"]

        # Add aliases
        for name in project.aliases.keys():
            phony_targets.append(name)

        f.write("# Phony targets\n")
        f.write(f".PHONY: {' '.join(phony_targets)}\n")
        f.write("\n")

    def _collect_directories(self, project: Project) -> None:
        """Collect all directories that need to be created."""
        # Collect from targets
        for target in project.targets:
            for node in self._get_target_build_nodes(target):
                parent = node.path.parent
                if parent != Path(".") and parent != Path(""):
                    self._directories.add(parent)
                # Track depfile directories
                build_info = getattr(node, "_build_info", None) or {}
                if build_info.get("depfile"):
                    depfile = Path(build_info["depfile"])
                    self._depfile_dirs.add(depfile.parent)

        # Collect from environment-tracked nodes
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode):
                    parent = node.path.parent
                    if parent != Path(".") and parent != Path(""):
                        self._directories.add(parent)

    def _write_directory_rules(self, f: TextIO) -> None:
        """Write rules to create directories."""
        if not self._directories:
            return

        f.write("# Directory creation\n")
        for directory in sorted(self._directories):
            escaped = self._escape_path(directory)
            f.write(f"{escaped}:\n")
            f.write("\tmkdir -p $@\n")
            f.write("\n")

    def _write_build_rules(self, f: TextIO, project: Project) -> None:
        """Write all build rules."""
        f.write("# Build rules\n")
        written_nodes: set[Path] = set()

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_rule(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _get_target_build_nodes(self, target: Target) -> list[FileNode]:
        """Get all buildable file nodes from a target."""
        nodes: list[FileNode] = []

        if getattr(target, "_resolved", False):
            # Resolved target (target-centric model)
            for obj_node in target.object_nodes:
                if isinstance(obj_node, FileNode):
                    nodes.append(obj_node)
            for out_node in target.output_nodes:
                if isinstance(out_node, FileNode):
                    nodes.append(out_node)
            # For interface targets (like Install), also check target.nodes
            if target.target_type == "interface":
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        has_build = (
                            getattr(target_node, "_build_info", None) is not None
                        )
                        if has_build:
                            nodes.append(target_node)
        else:
            # Legacy path: use target.nodes directly
            for target_node in target.nodes:
                has_build = (
                    target_node.builder is not None
                    or getattr(target_node, "_build_info", None) is not None
                )
                if isinstance(target_node, FileNode) and has_build:
                    nodes.append(target_node)

        return nodes

    def _write_target_builds(
        self,
        f: TextIO,
        target: Target,
        project: Project,
        written_nodes: set[Path],
    ) -> None:
        """Write build rules for a single target."""
        for node in self._get_target_build_nodes(target):
            if node.path not in written_nodes:
                self._write_build_rule(f, node, target, project)
                written_nodes.add(node.path)

    def _write_build_rule(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        project: Project,
    ) -> None:
        """Write a single build rule."""
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        sources: list[Node] = build_info.get("sources", [])

        # Handle multi-output builds
        outputs_info = build_info.get("outputs")
        if outputs_info:
            # Multi-output build - list all outputs
            all_outputs = [
                self._escape_path(info["path"]) for info in outputs_info.values()
            ]
            output = " ".join(all_outputs)
        else:
            output = self._escape_path(node.path)

        # Get source paths
        def get_source_path(s: FileNode) -> str:
            if not s.path.is_absolute():
                src_path = project.root_dir / s.path
                if src_path.exists():
                    return self._escape_path(src_path)
            return self._escape_path(s.path)

        # Build list of prerequisites
        prereqs: list[str] = []

        # Add sources
        for s in sources:
            if isinstance(s, FileNode):
                prereqs.append(get_source_path(s))

        # Add explicit deps (e.g., libraries for linking)
        source_paths_set = {s.path for s in sources if isinstance(s, FileNode)}
        for dep in node.explicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                prereqs.append(self._escape_path(dep.path))

        # Add implicit deps (e.g., headers discovered by scanners)
        for dep in node.implicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                prereqs.append(self._escape_path(dep.path))

        # Order-only prerequisites (directories)
        order_only: list[str] = []
        output_dir = node.path.parent
        if output_dir != Path(".") and output_dir != Path(""):
            order_only.append(self._escape_path(output_dir))

        # Build the target line
        prereq_str = " ".join(prereqs)
        if order_only:
            order_only_str = " | " + " ".join(order_only)
        else:
            order_only_str = ""

        f.write(f"{output}: {prereq_str}{order_only_str}\n")

        # Write the command
        command = self._get_command(node, target, project, sources)
        if command:
            f.write(f"\t{command}\n")

        f.write("\n")

    def _get_command(
        self,
        node: FileNode,
        target: Target | None,
        project: Project,
        sources: list[Node],
    ) -> str:
        """Get the build command for a node."""
        build_info = getattr(node, "_build_info", {})
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Get the environment from target
        env: Environment | None = None
        if target is not None:
            env = getattr(target, "_env", None)

        if env is None:
            # Try to find from project environments
            for e in project.environments:
                if node in getattr(e, "_created_nodes", []):
                    env = e
                    break

        if env is None:
            return f"@echo 'No environment for {node.path}'"

        # Get command template from tool config
        tool_config = getattr(env, tool_name, None)
        if tool_config is None:
            # Check for special copy command
            if tool_name == "copy":
                copy_cmd = build_info.get("copy_cmd", "cp $in $out")
                command = self._substitute_make_vars(
                    copy_cmd, node, sources, build_info
                )
                return self._append_post_build(command, node, target, sources)
            return f"@echo 'Unknown tool: {tool_name}'"

        command_template = getattr(tool_config, command_var, None)
        if command_template is None:
            return f"@echo 'No command template: {tool_name}.{command_var}'"

        # Expand the command template
        command = env.subst(command_template, shell="posix")

        # Substitute effective requirements
        command = self._substitute_effective_vars(command, build_info)

        # Substitute $in, $out with Make automatic variables
        command = self._substitute_make_vars(command, node, sources, build_info)

        # Append post-build commands if any
        command = self._append_post_build(command, node, target, sources)

        return command

    def _append_post_build(
        self,
        command: str,
        node: FileNode,
        target: Target | None,
        sources: list[Node],
    ) -> str:
        """Append post-build commands to the main command."""
        if target is None:
            return command

        # Check if this is an output node (not an intermediate object file)
        is_output_node = hasattr(target, "output_nodes") and node in target.output_nodes
        # Also check for legacy path where output nodes are in target.nodes
        if not is_output_node:
            is_output_node = node in target.nodes

        if not is_output_node:
            return command

        post_build_cmds = getattr(target, "_post_build_commands", [])
        if not post_build_cmds:
            return command

        # Substitute $out and $in in each command
        out_path = str(node.path)
        in_paths = " ".join(str(s.path) for s in sources if isinstance(s, FileNode))

        substituted_cmds = []
        for cmd in post_build_cmds:
            cmd = cmd.replace("$out", out_path)
            cmd = cmd.replace("$in", in_paths)
            substituted_cmds.append(cmd)

        # Chain commands with &&
        return command + " && " + " && ".join(substituted_cmds)

    def _substitute_effective_vars(
        self, command: str, build_info: dict[str, object]
    ) -> str:
        """Substitute effective requirement placeholders in command."""
        # Include directories
        effective_includes = build_info.get("effective_includes", [])
        if effective_includes and isinstance(effective_includes, list):
            include_flags = " ".join(f"-I{inc}" for inc in effective_includes)
            command = command.replace("$includes", include_flags)
        else:
            command = command.replace("$includes", "")

        # Defines
        effective_defines = build_info.get("effective_defines", [])
        if effective_defines and isinstance(effective_defines, list):
            define_flags = " ".join(f"-D{d}" for d in effective_defines)
            command = command.replace("$defines", define_flags)
        else:
            command = command.replace("$defines", "")

        # Extra compile flags
        effective_flags = build_info.get("effective_flags", [])
        if effective_flags and isinstance(effective_flags, list):
            flags_str = " ".join(str(f) for f in effective_flags)
            command = command.replace("$extra_flags", flags_str)
        else:
            command = command.replace("$extra_flags", "")

        # Link flags
        effective_link_flags = build_info.get("effective_link_flags", [])
        if effective_link_flags and isinstance(effective_link_flags, list):
            link_flags_str = " ".join(str(f) for f in effective_link_flags)
            command = command.replace("$ldflags", link_flags_str)
        else:
            command = command.replace("$ldflags", "")

        # Libraries
        effective_link_libs = build_info.get("effective_link_libs", [])
        if effective_link_libs and isinstance(effective_link_libs, list):
            libs_str = " ".join(f"-l{lib}" for lib in effective_link_libs)
            command = command.replace("$libs", libs_str)
        else:
            command = command.replace("$libs", "")

        # Library directories
        effective_link_dirs = build_info.get("effective_link_dirs", [])
        if effective_link_dirs and isinstance(effective_link_dirs, list):
            link_dirs_str = " ".join(f"-L{d}" for d in effective_link_dirs)
            command = command.replace("$libdirs", link_dirs_str)
        else:
            command = command.replace("$libdirs", "")

        # Clean up multiple spaces
        command = re.sub(r"\s+", " ", command).strip()

        return command

    def _substitute_make_vars(
        self,
        command: str,
        node: FileNode,
        sources: list[Node],
        build_info: dict[str, object],
    ) -> str:
        """Substitute $in/$out with actual paths (not Make automatic vars).

        We use explicit paths rather than $< and $@ because the sources
        may not match Make's automatic variable semantics exactly.
        """
        # Get source paths
        source_paths = " ".join(str(s.path) for s in sources if isinstance(s, FileNode))

        # Substitute $in and $out
        command = command.replace("$in", source_paths)
        command = command.replace("$out", str(node.path))

        # Handle depfile if present
        depfile = build_info.get("depfile")
        if depfile:
            command = command.replace("$out.d", str(depfile))

        return command

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write alias targets."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"{name}: {targets}\n")
        f.write("\n")

    def _write_default_target(self, f: TextIO, project: Project) -> None:
        """Write the default target."""
        defaults: list[str] = []

        # Add nodes from default targets
        for target in project.default_targets:
            if target.output_nodes:
                for out_node in target.output_nodes:
                    if isinstance(out_node, FileNode):
                        defaults.append(self._escape_path(out_node.path))
            else:
                for target_node in target.nodes:
                    if isinstance(target_node, FileNode):
                        defaults.append(self._escape_path(target_node.path))

        # If no default targets, auto-detect
        if not defaults:
            for target in project.targets:
                if getattr(target, "_resolved", False):
                    if target.target_type in (
                        "program",
                        "shared_library",
                        "static_library",
                    ):
                        for node in target.output_nodes:
                            if isinstance(node, FileNode):
                                defaults.append(self._escape_path(node.path))

        if defaults:
            f.write("# Default target\n")
            f.write(f"all: {' '.join(defaults)}\n")
            f.write(".DEFAULT_GOAL := all\n")
            f.write("\n")

    def _write_depfile_includes(self, f: TextIO) -> None:
        """Write includes for dependency files."""
        if not self._directories:
            return

        f.write("# Include dependency files (generated by compiler -MD flag)\n")
        # Include .d files from all directories that might have objects
        for directory in sorted(self._directories):
            f.write(f"-include {self._escape_path(directory)}/*.d\n")
        f.write("\n")

    def _write_clean_target(self, f: TextIO, output_dir: Path) -> None:
        """Write the clean target."""
        f.write("# Clean target\n")
        f.write("clean:\n")
        f.write(f"\trm -rf {self._escape_path(output_dir)}\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Makefiles.

        In Makefiles, $ must be escaped as $$. Spaces are tricky
        and generally should be avoided in build paths.
        """
        path_str = str(path)
        # Escape $ as $$
        return self.ESCAPE_DOLLAR.sub("$$", path_str)
